#!/usr/bin/env python3
# Program: Gen Edsdk From Headers
# Version: 0.1.0
# Author: Dr. Zulfiyor Bakhtiyorov
# Affiliations: University of Cambridge;
#   Xinjiang Institute of Ecology and Geography;
#   National Academy of Sciences of Tajikistan
# Year: 2025
# License: MIT License

"""Autogenerate edsdk/constants.py from EDSDK headers.
Usage:
  python tools/gen_edsdk_from_headers.py --headers /path/to/EDSDKTypes.h [/path/to/EDSDK.h ...] --out edsdk/constants.py
"""
import argparse
import pathlib
import re
import sys
from collections import OrderedDict


def collect_header_files(paths):
    files = []
    for hp in paths:
        p = pathlib.Path(hp)
        if p.is_dir():
            for ext in ("*.h", "*.hpp", "*.hxx"):
                files += list(p.rglob(ext))
        elif p.exists():
            files.append(p)
        else:
            print(f"[warn] path not found: {hp}", file=sys.stderr)
    # de-duplicate and sort
    seen, uniq = set(), []
    for f in files:
        s = str(f.resolve())
        if s not in seen:
            seen.add(s)
            uniq.append(pathlib.Path(s))
    return uniq


DEFINE_RE = re.compile(
    r"^\s*#\s*define\s+(k?Eds[A-Za-z0-9_]+)\s+([0-9xXa-fA-F\(\)\s\|\&\~\<\>\+\-]+)\s*$"
)
ENUM_RE = re.compile(
    r"typedef\s+enum[^{]*\{(?P<body>.*?)\}\s*(?P<name>Eds[A-Za-z0-9_]+)\s*;", re.S
)


def strip_comments(text: str) -> str:
    text = re.sub(r"/\*.*?\*/", "", text, flags=re.S)
    text = re.sub(r"//.*?$", "", text, flags=re.M)
    return text


# place near imports/globals:
IDENT_RE = re.compile(r"\b[A-Za-z_][A-Za-z0-9_]*\b")
CAST_RE = re.compile(
    r"\(\s*[A-Za-z_][A-Za-z0-9_\s\*\[\]]*\s*\)"
)  # strip casts like (EdsUInt32), (const int*), etc.


def parse_value(expr: str, ns: dict) -> int:
    """Parse simple numeric expressions from a C header.
    - substitute known identifiers (from ns)
    - remove C-style casts (for example, (EdsUInt32))
    - allow only safe operators: | & ~ << >> + - and parentheses
    """
    # drop typical suffixes
    expr = expr.replace("UL", "").replace("LU", "").replace("U", "").replace("L", "")
    # remove C casts (keep regular grouping parentheses)
    expr = CAST_RE.sub("", expr)

    # substitute known identifiers with their values
    def repl_ident(m):
        name = m.group(0)
        if name in ns:  # previously defined #defines or members of the current enum
            return str(ns[name])
        # numeric literals like 0x... are fine and will not hit this branch
        # unknown identifier: bail out
        raise ValueError(f"Unknown identifier: {name}")

    # only attempt substitution when expression still has letters
    if re.search(r"[A-Za-z_]", expr):
        expr = IDENT_RE.sub(repl_ident, expr)

    # final validation: allow only digits/operators/parentheses/spaces
    if not re.fullmatch(r"[0-9xXa-fA-F\s\|\&\~\<\>\+\-\(\)]+", expr):
        raise ValueError(f"Unsupported expression: {expr}")

    return eval(expr, {"__builtins__": {}}, {})


def parse_defines(text: str, ns: dict):
    consts = OrderedDict()
    for line in text.splitlines():
        m = DEFINE_RE.match(line)
        if not m:
            continue
        name, expr = m.group(1), m.group(2)
        try:
            val = parse_value(expr, {**consts, **ns})
        except Exception:
            continue  # skip complex macros depending on unknown names
        consts[name] = val
    return consts


def parse_enums(text: str, ns: dict):
    enums = OrderedDict()
    for m in ENUM_RE.finditer(text):
        body = m.group("body")
        ename = m.group("name")
        value = -1
        members = OrderedDict()
        for raw in body.split(","):
            token = raw.strip()
            if not token:
                continue
            token = token.split("/*")[0].strip()
            if "=" in token:
                n, expr = [t.strip() for t in token.split("=", 1)]
                value = parse_value(expr, {**members, **ns})
            else:
                value += 1
                n = token
            if not re.fullmatch(r"[A-Za-z_][A-Za-z0-9_]*", n):
                continue
            members[n] = value
        if members:
            enums[ename] = members
    return enums


def is_flag_enum(values):
    vals = [v for v in values if v >= 0]
    if not vals:
        return False
    pow2 = sum((v != 0 and (v & (v - 1)) == 0) for v in vals)
    seq = sum((i > 0 and vals[i] == vals[i - 1] + 1) for i in range(len(vals)))
    return pow2 >= max(2, len(vals) // 2) and seq <= len(vals) // 4


TEMPLATE = """# AUTOGENERATED FILE. DO NOT EDIT.
# Generated by tools/gen_edsdk_from_headers.py
from enum import IntEnum, IntFlag

# flat dict: constant name -> int value
ALL_CONSTANTS = {{
{flat_constants}
}}

{enums}
"""


def render_enums(enums: OrderedDict) -> str:
    parts = []
    for ename, members in enums.items():
        values = list(members.values())
        base = "IntFlag" if is_flag_enum(values) else "IntEnum"
        parts.append(f"class {ename}({base}):")
        for n, v in members.items():
            parts.append(f"    {n} = {hex(v) if v>9 else v}")
        parts.append("")
    return "\n".join(parts)


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--headers", nargs="+", required=True)
    ap.add_argument("--out", required=True)
    args = ap.parse_args()

    text = ""
    header_files = collect_header_files(args.headers)
    if not header_files:
        print("[error] no header files found", file=sys.stderr)
        sys.exit(2)

    for p in header_files:
        try:
            text += "\n" + p.read_text(encoding="utf-8", errors="ignore")
        except (PermissionError, OSError) as e:
            print(f"[warn] cannot read {p}: {e}", file=sys.stderr)

    print(f"[ok] parsed {len(header_files)} header(s)")
    text = strip_comments(text)

    ns = {}
    defines = parse_defines(text, ns)
    ns.update(defines)
    enums = parse_enums(text, ns)

    flat = OrderedDict(defines)
    for _, mem in enums.items():
        flat.update(mem)

    flat_txt = "\n".join(
        [f"    '{k}': {hex(v) if v>9 else v}," for k, v in flat.items()]
    )
    enums_txt = render_enums(enums)

    outp = pathlib.Path(args.out)
    outp.parent.mkdir(parents=True, exist_ok=True)
    outp.write_text(
        TEMPLATE.format(flat_constants=flat_txt, enums=enums_txt), encoding="utf-8"
    )
    print(f"[ok] wrote {outp}")


if __name__ == "__main__":
    main()

# Created by Dr. Z. Bakhtiyorov
